"Previous Section"_Manual.html - "PHISH WWW Site"_pws -
"PHISH Documentation"_pd - "Next Section"_Bait.html :c

:link(pws,http://phish.sandia.gov)
:link(pd,Manual.html)

:line

1. Introduction :h3

This section explains what the PHISH software package is and why we
created it.  It outlines the steps to creating your own PHISH program,
and gives a simple of using PHISH to perform a parallel calculation.
These are the topics discussed:

1.1 "Motivation"_#intro_1
1.2 "PHISH lingo"_#intro_2
1.3 "PHISH pheatures"_#intro_3
1.4 "Steps to creating and running a PHISH net"_#intro_4
1.5 "Simple example"_#intro_5
1.6 "Acknowledgments and citations"_#intro_6 :ul

:line
:line

1.1 Motivation :link(intro_1),h4

Informatics is data-driven computing and is becoming more prevalent,
even on large-scale parallel machines, traditionally used to run
scientific simulations.  It can involve processing large archives of
stored data or data that arrives on-the-fly in real time.  THe latter
is often referred to as "streaming" data.  Common attributes of
streaming data are that it arrives continuously in a never-ending
stream, its fast incoming rate requires it be processed as it arrives
which may limit the computational effort per datum that can be
expended, and its high volume means it cannot be stored permanently so
that individual datums are examined and discarded.

A powerful paradigm for processing streaming data is to use a
collection of programs, running as independent processes, connected
together in a specified communication topology.  Each process receives
datums continuously, either from the stream itself, read from a file,
or sent to it from other processes.  It performs calculations on each
datum and may choose to store "state" internally about the stream it
has seen thus far.  It can send the datum on to one or more other
processes, either as-is or in an altered form.

In this model, a data-processing algorithm can be expressed by
choosing a set of processes (programs) and connecting them together in
an appropriate fashion.  If written flexibly. individual programs can
be re-used in different algorithms.

PHISH is a small software package we created to make the task of
designing and developing such algorithms easier, and allowing the
resulting program to be run in parallel, either on distributed memory
platforms that support MPI message passing, or on a collection of
computers that support socket connections between them.

PHISH stands for Parallel Harness for Informatic Stream Hashing.

Parallelism can be achieved by using multiple copies of processes,
each working on a part of the stream.  It is a framework or harness
for connecting processes in a variety of simple, yet powerful, ways
that enable parallel data processing.  While it is desinged with
streaming data in mind, it can also be used to process archived data
from files or in a general sense to perform a computation in stages,
using internally generated data of any type or size.  Hashing refers
to sending datums to specific target processes based on the result of
a hash operation, which is one means of achieving parallelism.

It is important to note that PHISH does not replace or even automate
the task of writing code for the individual programs needed to process
data, or of designing an appropriate parallel algorithm to perform a
desired computation.  It is simply a library that processes can call
to exchange datums with other processes, and a set of setup tools that
convert an input script into a runnable program and allow it to be
easily launched in parallel.

Our goal in developing PHISH was to make it easier to process data,
particularly streaming data, in parallel, even on distributed-memory
or geographically-distributed platforms.  And to provide a framework
to quickly experiment with parallel informatics algorithms, either for
streaming or archived data.  Our own interest is in graph algorithms
but various kinds of statistical, data mining, machine learning, and
anomaly detection algorithms can be formulated for streaming data, in
the context of the model described above.

:line

1.2 PHISH lingo :link(intro_2),h4

The name PHISH was also chosen because it evokes the idea of one or
more fish swimming in a stream (of data).  This unavoidably gives rise
to the following PHISH lingo, which we use without apology throughout
the rest of the documentation:

minnow = a (typically small) stand-alone application, run as an individual process
school = a set of duplicate minnows, working (swimming) in a coordinated fashion
net(work) = a PHISH program, typically consisting of multiple minnow schools, connected together to perform a calculation, as in the diagram below
bait = Bait.py = a script for hooking schools of minnows together into a net
wrapper = a Python wrapper for the PHISH library, included in the PHISH distribution :ul

:line

1.3 PHISH pheatures :link(intro_3),h4

The model described above is not unique to PHISH.  Many programs
provide a framework for moving chunks of data between computational
tasks interconnected by "pipes" in a data-flow kind of paradigm.
Visualization programs often use this model to process data and
provide a GUI framework for building a processing pipeline by
connecting the outputs of each computational node to the inputs of
others.  The open source Titan package, built on top of VTK, is one
example, which provides a rich suite of computation methods, both for
visualization and data processing.  The commercial DataMiner tool from
IBM uses a similar dataflow model, and is designed for processing
streaming data at high rates.

These programs include a suite of processing modules and are typically
designed to run as a single process or in parallel on a shared memory
machine.  The computational nodes in the processing pipeline are
functions called as needed by a master process, or launched as threads
running in parallel.  This means data can be sent from one
computational task to another in a low-overhead fashion by passing a
pointer or via shared memory buffers.  (Is the preceding true, does
Titan have nodes that can do MPI-style paralellism?).

By contrast, PHISH minnows (nodes in the processing pipeline), are
independent processes and the PHISH library moves data between them
via "messages" which requires copying the aata, either using the
message-passing MPI library or sockets.  This allows PHISH programs to
be run on a broader range of hardware, and PHISH minnows to be
developed as independent stand-alone applications, but also incurs a
higher overhead for moving data from process to process.

The following list highlights additional PHISH pheatures:

The PHISH package is open-source software, distributed under the
Berkeley Software Development (BSD) license.  This effectively means
that anyone can use the software for any purpose, including commercial
redistribution. :ulb,l

The PHISH library is a small piece of code (couple 1000 lines), with a
compact API (couple dozen functions).  It is written in C++, with a
C-style interface, so that it can be easily called from programs
written in a variety of languages (C, C++, Fortran, Python, etc).  The
library is highly portable and can be compiled on any platform with a
C++ compiler. :l

The PHISH library comes in two flavors with the same API: one based on
message passing via the MPI library, one based on sockets.  The latter
uses the open-source ZMQ library.  This means you need one or both of
these packages (MPI, ZMQ) installed on your machine to build a program
(minnow) that uses the PHISH library. :l

A Python wrapper for the PHISH library is provided, so that programs
(minnows) that call the PHISH library can be written in Python. :l

The PHISH library encodes data exchanged between processes (minnows)
with strict data typing rules, so that data can be passed between
programs written in different languages (e.g. C++ vs Fortran vs
Python) and running on different machines (4-byte vs 8-byte integers).
Eventually, we may also allow for data exchange between machines with
different floating point representations or endian ordering of data
types. :l

PHISH programs (nets) which involve coordinated computation and data
exchange between many processes (minnows) can be specified in PHISH
input scripts, which are text files with a simple command syntax. :l

PHISH input scripts use a "connect"_bait_connect.html command which
allows data to be exchanged in various patterns between collections of
independent processes (minnows).  This enables parallelism in data
processing to be easily expressed and exploited. :l

PHISH input scripts can be converted into launch scripts via a
provided Bait.py program.  This produces a file suitable for running
either with MPI or sockets. :l

PHISH programs (nets) running on top of MPI are launched via the
standard mpirun or mpiexec command.  Note that a PHISH net is
different than the usual MPI program run on P processors where P
copies of the same executable are launched.  A PHISH net typically
consists of several different schools of minnows; each minnow is an
independent executable. :l

PHISH programs (nets) running on top of sockets are launched via a
provided Python script, called Launch.py, which mimics the operation
of mpirun.  It invokes the set of independent processes (minnows) on
various machines via ssh commands, sets up the socket connections
between them, and synchrnoizes their launch so that no data is dropped
as the processes (minnows) begin exchanging data. :l

PHISH programs (nets) can be run on a single processor, so long as the
OS supports multiple processes.  They can be run on a multicore box.
They can be run on any distributed-memory or shared-memory platform
that supports MPI or sockets.  Or they can be run on a geographically
dispersed set of machines that support socket connections. :l

A PHISH program (net) can look for incoming data on a socket port.  It
can likewise export data to a socket port.  This means that two or
more PHISH programs (nets) can be launched independently and exchange
data.  This is a mechanism for adding/deleting processes (minnows)
to/from a calculation on the fly. :l

A handful of programs (minnows) that call the PHISH library are
provided in the distribution, as are some example PHISH input scripts
that encode PHISH programs (nets).  Makefiles are also provided to
assist in creating and building your own new programs (minnows). :l

Programs (minnows) are provided that wrap non-PHISH applications that
read from stdin and/or write to stdout.  This allows those executables
to be used in a PHISH program (net) and exchange data with other
programs (minnows). :l,ule

:line

1.4 Steps to creating and running a PHISH net :link(intro_4),h4

The PHISH package contains a library and several related tools for
defining and running PHISH nets.  These are the steps and associated
tools typically used to perform a calculation, assuming you have
designed an algorithm that can be encoded as a series of computational
tasks, interconnected by moving chunks of data between them.

build the PHISH library
write and build one or more minnows that call the PHISH library
write an input script defining a PHISH net, as schools of minnows and the communication patterns connecting them
uss the bait.py tool to process the input script
use mpirun or Launch.py to run the output file created by Bait.py,
and perform the calculation :ol

Step (1): An overview of the PHISH library and instructions for how to
build it is given in "this section"_Section_library.html.

Step (2): A minnow is a stand-alone application which makes calls to
the PHISH library.  An overview of minnows, their code structure, and
how to build them, is given in "this section"_Section_minnows.html.
The API to the PHISH library is given in "this
section"_Section_library.html, with links to a doc page for each
function in the library.

Step (3): The syntax and commands used in PHISH input scripts are
described in "this section"_Section_bait.html, with links to
individual commands that explain their operation and options.

Step (4): The bait.py tool, its command-line options, and instructions
on how to run it, are described in "this section"_Section_bait.html.

Step (5): Bait.py produces a file as output.  If the "-mode mpich" or
"-mode openmpi" switch was used, the file can be run using the
standard mpirun command to run a parallel job.  In all the
examples that follow, "outfile" is the name of the file
produced by bait.py.

For MPICH, you would do this as follows:

mpiexec -configfile outfile :pre

For OpenMPI, you would do this as follows:

mpirun -configfile outfile :pre

If the "-mode socket" switch was used with bait.py, then
the file can be run using the Launch.py tool, as follows:

launch.py ... outfile :pre

TIM: Launch.py support the following command-line arguments ...

TIM: Does launch.py need its own doc page?

:line

1.5 Simple example :link(intro_5),h4

The steps outlined in the preceding section are somewhat abstract.
Here is a concrete example of using a PHISH program to count the
number of times different words appear in a corpus of text files.
This is effectively a MapReduce operation, where individual minnow
processes perform the map() and reduce() functions.  This is a diagram
of how 5 different kinds of minnows can beconnected together to
perform the computation:

:c,image(JPG/wordcount.jpg)

Code for all 5 of these minnows is in the example directory of the
PHISH distribution, both in C++ and Python.  The {FileGen} minnow
takes a list of files and/or directories as user input, searches them
recursively, and generates a series of filenames.  The filenames are
sent one-at-a-time to one of several {File2Words} minnows.  Each
receives a filename as input, opens and reads the content, and parses
it into words.  Each word is hashed and sent to a specific {Count}
minnow.  The key point is that each {Count} minnow will receive all
occurrences of a subset of possible words.  It stores an internal hash
table and counts the occurrences of each word it receives.

When the {FileGen} minnow sends the last filename if finds, it sends a
"done" message to each of the {File2Words} minnows.  When they receive
a "done" message, they send a "done" message to each {Count} minnow.
When a {Count} minnow receives a "done" message from all the
{File2Words} minnows, it sends its entire list of unique words and
associated counts to the {Sort} minnow, followed by a "done" message.
When the {Sort} minnow has received "done" message from all the
upstream {Count} minnows, it knows it has received a list of all the
unique words in the corpus of documents, and the count for each one.
It sorts the list by count and sends the top {N} to the {Print}
minnow, one by one, followed by a "done" message.  {N} is a
user-defined parameter.  The {Print} minnow echoes each datum it
receives to the screen or a file, until if receives a "done" message.
At this point all minnows in the school have been shut down.

More details about this example are discussed in subsequent sections
of the manual.

In "this section"_Section_bait.html#bait_4 of the "Bait.py
Tool"_Bait.html doc page, the PHISH input script that encodes the
minnows and communication connections of the above diagram is
discussed, and its processing by the "bait.py"_Bait.html tool.

In "this section"_Section_minnows.html#minnow_1 of the "PHISH
Minnows"_Minnows.html doc page, the code for the {Count} minnow is
discussed in detail, to illustrate what calls it makes to the "PHISH
library"_Library.html to send and receive datums.

In "this section"_Section_library.html#datum of the "PHISH
Library"_Library.html doc page, the format of datums exchanged between
minnows is discussed.

Note that like a MapReduce, the PHISH program runs in parallel, since
there can be N {File2Words} minnows and M {Count} minnows where N >=1,
M >=1, and N = M is not required.  This is similar to the option in
"Hadoop"_hadoop to vary the numbers of mappers and reducers.

However, there are also some differences between how this PHISH
program works as compared to a traditional MapReduce, e.g. as
typically performed via "Hadoop"_hadoop or the "MapReduce-MPI
library"_mrmpi.

In a traditional MapReduce, the "map" stage (performed by the
{File2Words} minnows) creates a huge list of all the words, including
duplicates, found in the corpus of documents, which is stored
internally (in memory or on disk) until the "mapper" process is
finished with all the files it processes.  Each mapper then sends
chunks of the list to each "reduce" process (performed by the {Count}
minnows).  This is the "shuffle" phase of a Hadoop MapReduce.
The reducer performs a merge sort of all the words in the chunks
it receives (one from each mapper).  It can then calculate the
count for each unique word.

In contrast, the PHISH program operates in a more continuous fashion,
streaming the data (words in this case) through the minnows, without
ever storing the full data set.  Only a small list of unique words is
stored (by the {Count} minnows), each with a running counter.  In this
example, PHISH exchanges data between minnows via many tiny messages
(one word per message), whereas a traditional MapReduce would
aggregate the data into a few large messages.

This is a simplistic explanation; a fuller description is more
complex.  "Hadoop"_hadoop, for example, can operate in streaming mode
for some forms of MapReduce operations, which include this wordcount
example.  (MapReduce operations where the "reducer" needs all data
associated with a key at one time, are not typically amenable to a
streaming mode of operation.)  The PHISH minnows used in this school
could be modified so as to aggregate data into larger and fewer
messages.

However the fundamental attributes of the PHISH program are important
to understand.  Data moves continuously, in small chunks, through a
school of minnows.  Each minnow may store "state" information about
the data it has previously seen, but typically not all the data
itself.  "State" is typically limited to information that can be
stored in-memory, not on disk.  This is because for streaming data,
too much data arrives too quickly, for a minnow to perform much
computation before discarding it or sending it on to another minnow.

Here is a diagram of a variant of the wordcount operation that
illustrates how PHISH can be used to process continuous, streaming
data.  The PHISH program in this case might run for days or weeks,
without using the "done" messages described above.

:c,image(JPG/wordcount2.jpg)

In this case the {FileGen} minnow is continuously seeing new files
appear in directories it monitors.  The words in those files are
processed as they appear.  A {Trigger} minnow has been added which
accepts user queries, e.g. via a keyboard or a socket connection.
When the user makes a request (hits a key), a message is sent to each
of the {Count} minnows on a different input port than it receives
words from the {File2Words} minnows; see "this
section"_Minnows.html#minnow_2 of the "PHISH Minnows"_Minnows.html doc
page for a discussion of ports.  The message triggers the {Count}
minnows to send their current unique word/count list to the {Sort}
minnow which is sorted and printed via the {Print} minnow.

The PHISH job now runs continuously and a user can query the current
top N words as often as desired.  The {FileGen}, {Count}, and {Sort}
minnows would have to be modified, but only in small ways, to work in
this mode.  Additional logic could be added (e.g. another user
request) to re-initialize counts or accumulate counts in a
time-windowed fashion.

:line

1.6 Acknowledgments and citations :link(intro_6),h4

PHISH development has been funded by the US Department of Energy (DOE),
through its LDRD program at Sandia National Laboratories.

The following paper describe the basic ideas in PHISH.  If you use
PHISH in your published work, please cite this paper and include a
pointer to the PHISH WWW Site (http://phish.sandia.gov):

S. J. Plimpton and T. Shead, PHISH in action, J Parallel and
Distributed Compuing, submitted (2012).

PHISH was developed by the following individuals at Sandia:

Steve Plimpton, sjplimp at sandia.gov
Tim Shead, tshead at sandia.gov :ul

PHISH comes with no warranty of any kind. As each source file states
in its header, it is a copyrighted code that is distributed free-of-
charge, under the terms of the Berkeley Softward Distribution (BSD)
License. 

Source code for PHISH is freely available for download from the "PHISH
web site"_pws and is licensed under the modified "Berkeley Software
Distribution (BSD) License"_bsd.  This basically means they can be
used by anyone for any purpose.  See the LICENSE file provided with
the distribution for more details.
