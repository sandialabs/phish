<HTML>
<CENTER><A HREF = "Minnows.html">Previous Section</A> - <A HREF = "http://phish.sandia.gov">PHISH WWW Site</A> -
<A HREF = "Manual.html">PHISH, Documentation</A> - <A HREF = "Examples.html">Next Section</A> 
</CENTER>




<HR>

<H3>4. PHISH Library 
</H3>
<P>This is the API to the PHISH library that PHISH minnows call.  In
PHISH lingo, a "minnow" is a stand-alone application which makes calls
to the <A HREF = "Library.html">PHISH library</A>.
</P>
<P>The API for the MPI and socket verions of the PHISH library are
identical.
</P>
<P>A general discussion of how and when minnows call PHISH library
functions is given in the <A HREF = "Minnows.html">Minnows</A> section of the
manual.
</P>
<P>The PHISH library has a C-style API, so it is easy to write minnows in
any language, e.g. C, C++, Fortran, Python.  A C++-style API is also
provided, which means a C++ program can use either the C or C++ API.
A Python wrapper on the C-style API.  The doc pages for individual
library functions document all 3 APIs; they are very similar.  See the
section below entitled <A HREF = "#library_2">C vs C++ vs Python interface</A> for a
quick overview.
</P>
<P>PHISH minnows communicate with other minnows by sending and receiving
datums.  Before looking at individual library calls, it may be helpful
to understand how data is stored internally in a datum by the PHISH
library.  This topic is discussed below, in the section entitled
<A HREF = "#library_3">Format of a datum</A>.
</P>
<P>NOTE: Say something about using int32 or uint32 versus just int in
minnow.  Either here and in datum format section and in phish_pack
doc page.
</P>
<UL><LI>4.1 <A HREF = "#library_1">List of library functions</A>
<LI>4.2 <A HREF = "#library_2">C vs C++ vs Python interface</A>
<LI>4.3 <A HREF = "#library_3">Format of a datum</A> 
</UL>
<HR>

<HR>

<A NAME = "library_1"></A><H4>4.1 List of library functions 
</H4>
<P>The PHISH library is not large; there are only a handful of calls.
They can be grouped into the following categories.  Follow the links
to see a doc page for each library call.  
</P>
<OL><LI>Library calls for initialization 

<UL>  <A HREF = "phish_init.html">phish_init()</A> 
<BR>
  <A HREF = "phish_port.html">phish_input()</A> 
<BR>
  <A HREF = "phish_port.html">phish_output()</A> 
<BR>
  <A HREF = "phish_callback.html">phish_callback()</A> 
<BR>
  <A HREF = "phish_check.html">phish_check()</A> 
<BR></UL>
<LI>Library calls for shutdown 

<UL>  <A HREF = "phish_shutdown.html">phish_exit()</A> 
<BR>
  <A HREF = "phish_shutdown.html">phish_close()</A> 
<BR></UL>
<LI>Library calls for receiving datums 

<UL>  <A HREF = "phish_loop.html">phish_loop()</A> 
<BR>
  <A HREF = "phish_probe.html">phish_probe()</A> 
<BR>
  <A HREF = "phish_recv.html">phish_recv()</A> 
<BR>
  <A HREF = "phish_unpack.html">phish_unpack()</A> 
<BR>
  <A HREF = "phish_unpack.html">phish_datum()</A> 
<BR></UL>
<LI>Library calls for sending datums 

<UL>  <A HREF = "phish_send.html">phish_send()</A> 
<BR>
  <A HREF = "phish_send.html">phish_send_key()</A> 
<BR>
  <A HREF = "phish_send.html">phish_send_direct()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_repack()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_raw()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_char()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_int8()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_int16()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_int32()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_int64()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_uint8()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_uint16()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_uint32()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_uint64()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_float()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_double()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_string()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_int8_array()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_int16_array()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_int32_array()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_int64_array()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_uint8_array()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_uint16_array()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_uint32_array()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_uint64_array()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_float_array()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_double_array()</A> 
<BR>
  <A HREF = "phish_pack.html">phish_pack_pickle()</A> 
<BR></UL>
<LI>Library calls for queueing datums 

<UL>  <A HREF = "phish_queue.html">phish_queue()</A> 
<BR>
  <A HREF = "phish_queue.html">phish_dequeue()</A> 
<BR>
  <A HREF = "phish_queue.html">phish_nqueue()</A> 
<BR></UL>
<LI>Miscellaneous library calls 

<UL>  <A HREF = "phish_info.html">phish_query()</A> 
<BR>
  <A HREF = "phish_info.html">phish_set()</A> 
<BR>
  <A HREF = "phish_error.html">phish_error()</A> 
<BR>
  <A HREF = "phish_error.html">phish_warn()</A> 
<BR>
  <A HREF = "phish_error.html">phish_abort()</A> 
<BR>
  <A HREF = "phish_timer.html">phish_timer()</A> 
<BR></UL>

</OL>
<HR>

<A NAME = "library_1"></A><H4>4.2 C vs C++ vs Python interface 
</H4>
<P>As noted above, the APIs to the PHISH library for
C versus C++ versus Python are very simliar.  A C++ program
can use either the C or C++ API.
</P>
<P>To use the C interface, a C or C++ program includes the file
src/phish.h and makes calls to functions as follows:
</P>
<PRE>#include "phish.h"
phish_error("My error"); 
</PRE>
<P>NOTE: should namespace be PHISH or phish or Phish?
      change in phish.hpp accordingly
</P>
<P>The C++ interface in src/phish.hpp encloses the PHISH API in the
namespace "PHISH", so functions can be invoked as
</P>
<PRE>#include "phish.hpp"
PHISH::error("My error"); 
</PRE>
<P>or as
</P>
<PRE>#include "phish.hpp"
using namespace PHISH
error("My error"); 
</PRE>
<P>To use the Python interface, the Python PHISH wrapper needs to be
installed in your machine's Python.  See <A HREF = "Section_python.html">this
section</A> of the manual for details.
A Python program can then invoke a library function as
</P>
<PRE>import phish
phish.error("My error") 
</PRE>
<HR>

<A NAME = "library_3"></A><H4>4.3 Format of a datum 
</H4>
<P>Care taken to pack datum with expliclty sized values, since may be
done on different machines, with different word lengths.  At some
point, might worry about endian swapping.  Force you to use explicit
pack functions.  Also the flags are 32-bit ints.  At some point if can
make float/double portable, will enforce that too.
</P>
<P>A datum is a chunk of bytes sent from one PHISH minnow to another.
This section describes the format of the chunk, which is the same whether
the datum is sent via MPI or via sockets.
</P>
<P>NOTE: discuss and use int32_t in what is below
</P>
<UL><LI># of fields in datum (int)
<LI>type of 1st field (int)
<LI>size of 1st field (optional int)
<LI>data for 1st field (bytes)
<LI>type of 2nd field (int)
<LI>size of 2nd field (optional int)
<LI>data for 2nd field (bytes)
<LI>...
<LI>type of Nth field (int)
<LI>size of Nth field (optional int)
<LI>data for Nth field (bytes) 
</UL>
<P>The "type" values are one of these settings, as defined in src/phish.h:
</P>
<UL><LI>PHISH_RAW = 0
<LI>PHISH_CHAR = 1
<LI>PHISH_INT8 = 2
<LI>PHISH_INT16 = 3
<LI>PHISH_INT32 = 4
<LI>PHISH_INT64 = 5
<LI>PHISH_UINT8 = 6
<LI>PHISH_UINT16 = 7
<LI>PHISH_UINT32 = 8
<LI>PHISH_UINT64 = 9
<LI>PHISH_FLOAT = 10
<LI>PHISH_DOUBLE = 11
<LI>PHISH_STRING = 12
<LI>PHISH_INT8_ARRAY = 13
<LI>PHISH_INT16_ARRAY = 14
<LI>PHISH_INT32_ARRAY = 15
<LI>PHISH_INT64_ARRAY = 16
<LI>PHISH_UINT8_ARRAY = 17
<LI>PHISH_UINT16_ARRAY = 18
<LI>PHISH_UINT32_ARRAY = 19
<LI>PHISH_UINT64_ARRAY = 20
<LI>PHISH_FLOAT_ARRAY = 21
<LI>PHISH_DOUBLE_ARRAY = 22
<LI>PHISH_PICKLE = 23 
</UL>
<P>NOTE: add info on all new data types
</P>
<P>NOTE: discuss why are picky about int32, etc so can be
portable across machines
</P>
<P>PHISH_RAW is a string of raw bytes, which can be of any length, and
which the minnow can format in any manner.  PHISH_BYTE, PHISH_INT,
PHISH_UINT64, and PHISH_DOUBLE are a single byte, int, uint64, and
double value.  PHISH_INT is a signed int, typically 32-bits in length.
PHISH_UINT64 is an unsigned 64-bit int.  PHISH_STRING is a standard
C-style NULL-terminated C-string.  The NULL is included in the field.
The ARRAYS are contiguous sequences of int, uint64 or double values.
</P>
<P>The "size" values are only included for PHISH_RAW (# of bytes),
PHISH_STRING (# of bytes including NULL), and the ARRAY types (# of
values).
</P>
<P>The field data is packed into the datum in a contiguous manner.
This means that no attention is paid to alignment of integer
or floating point values.
</P>
<P>The maximum allowed size of an entire datum (in bytes) is set by
MAXBUF in src/phish.cpp, which defaults to 1 Mbyte.
</P>
<P>NOTE: this is now a user-settable parameter
</P>
<P>When a datum is sent via the MPI version of the PHISH library, MPI
flags the message with an MPI "tag".  This tag encodes the receiving
minnow's input port and also a "done" flag.  Specifically, if the
datum is not a done message, the tag is the receiver's input port (0
to Nport-1).  For a done message a value of MAXPORT (defined at the
top of src/phish.cpp) is added to the tag.
</P>
<P>NOTE: MAXPORT is hardwired, could re-compile - this is
so all minnows use same setting.
</P>
<P>See the <A HREF = "phish_port.html">phish_input</A> doc page for a discussion of
ports.  See the <A HREF = "Minnows.html#shutdown">shutdown section</A> of the
<A HREF = "Minnows.html">Minnows</A> doc page for a discussion of "done" messages.
</P>
<P>TIM: How is this encoding of port and done implemented for sockets?
</P>
</HTML>
