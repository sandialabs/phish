<HTML>
<CENTER><A HREF = "Manual.html">Previous Section</A> - <A HREF = "http://phish.sandia.gov">PHISH WWW Site</A> -
<A HREF = "Manual.html">LAMMPS Documentation</A> - <A HREF = "Bait.html">Next Section</A> 
</CENTER>




<HR>

<H3>1. Introduction 
</H3>
<P>NOTE: post citation to MR-MPI paper in PC
</P>
<P>NOTE: so long, and thanks for all the phish (with apologies to Douglas Adams)
</P>
<P>NOTE: Remember, a dead phish can float downstream, but it takes a live
one to swim upstream.  W. C. Fields
</P>
<P>NOTE: This WWW site is not about Phish the band, or illicit phishing
for your personal info, but about PHISH, a software package for
writing parallel programs that process streaming data.
</P>
<P>This section explains what the PHISH software package is and why we
created it.  It describes a simple example of using PHISH to perform a
parallel calculation and highlights the steps to creating your own
PHISH program.  These are the topics discussed:
</P>
<UL><LI><A HREF = "#intro_1">Motivation</A>
<LI><A HREF = "#intro_2">PHISH Pheatures</A>
<LI><A HREF = "#intro_3">PHISH lingo</A>
<LI><A HREF = "#intro_4">Simple example</A>
<LI><A HREF = "#intro_5">Steps to creating and running a PHISH program</A>
<LI><A HREF = "#intro_6">Acknowledgments and citations</A> 
</UL>
<HR>

<HR>

<A NAME = "intro_1"></A><H4>Motivation 
</H4>
<P>what is streaming data
 continuous
 high bandwidth
 cannot afford to see it more than once
</P>
<P>goals: informatics data in broadest sense, stats, data mininng,
 anomaly detection
</P>
<P>powerful paradigm: stateful independent processes, that
 are small programs that do one things, run a large collection
 of these that communicate is a designed fashion, to acheive
 parallelism, running
 that ship datums (chunk of bytes) to each other in continuous
 fashion.  Can be infinite stream or processing of large
 archive of data
</P>
<P>what kind of algorithms can be expressed in this mode?
various stream models of computation: e.g. W-stream, X-stream
our own interest is graph algorithms and data mining on 
hi-volume streams of data, but many other data processing
tasks can be formulated in this fashion
</P>
<P>other products: DataMiner from IBM (see Karl list)
</P>
<P>dropping data versus perfrect answer (pipeline throttles itself)
</P>
<P>why we wrote PHISH
 different than typicaly MPI where all procs run one program
 wanted to go beyond MPI to sockets, hetergenous machines
   add/delete minnows dynamically
 wanted to automate some of the parallelism inherent in 
   processing big data, a la MapReduce (this is the hashing idea)
 make it as simple as possible to process data in parallel
</P>
<P>all of these goals reflected in name PHISH
</P>
<HR>

<P>PHISH Pheatures:link(intro_1),h4
</P>
<P>lib = simple (1000 lines), C-interface, portable (list langaunges),
Python (phish) wrapper provided
</P>
<P>The individual programs can be written in any language (e.g. C, C++,
Fortran, Python) and link to the PHISH library so that they can
receive incoming data from upstream sources, bundle their data, and
send it downstream.
</P>
<P>paralllel data procesing via parallel launch or hashing
</P>
<P>lib on top of MPI or sockets - latter via ZMQ lib
(geogrphically diverse machines)
</P>
<P>mechanism to hook multiple PHISH schools togehter via sockets
 means can add/delete processes
</P>
<P>examples for streaming MR, CC finidng in parallel, MR-like jobs
</P>
<P>benchmarks for running on MPI or sockets
</P>
<P>minnows that let you wrap existing stand-alone programs that
read from stdin and write to stdout
</P>
<P>Can wrap existing apps in PHISH (fish-wrapper).
Minnows are provided
</P>
<P>portable open-source lib, lightweight, easy to call
from any language, including Python
</P>
<P>easy path to distributed memory parallel for processing
streaming data
</P>
<P>shutdown via done messages
</P>
<P>The PHISH package is open-source software that implements the
<A HREF = "wiki">MapReduce operation</A> popularized by Google on top of standard
MPI message passing.
</P>
<HR>

<P>PHISH lingo:link(intro_1),h4
</P>
<P>phish wrapper
</P>
<P>Minnows read (swim in) stream, process datums,
can store state, consume or write (altered) datums.
</P>
<P>minnow = stand-alone program (app) that (typically)
does one task, designed to work in tandem with other
minnows, either copies of itself, or totally different
</P>
<P>School of minnows and their connectivity specified
in simple input script, processed with bait.py to
turn into launchable parallel job, either via MPI and
mpirun, or via sockets and a shell script.
</P>
<P>each stand-alone minnow calls library
</P>
<P>ulterior motive, phish swim in a stream, minnows 
are small, but work in coordinated fashion to some
goal (evade preadtor, find food)
</P>
<P>brings us to PHISH lingo
</P>
<P>minnow: read and compute on and write (altered) datums
school: collection of minnows
bait the hook via bait.py
phish wrapper = Python
</P>
<P>explain acronym
what each word means
</P>
<P>minnow
school
input script
bait.py
</P>
<P>school of minnows swim in a stream, doing something
coordinated.
</P>
<P>A PHISH input script allows specification of the set of programs to
launch as independent processes, how many copies of each are inovked,
and the topology of how they connect to each other as they send and
receive data.  Thus the input script encodes an algorithm for
processing continuous data from a stream source or archived data from
files.  The supported communication topologies include a "hashed" mode
of messaging where a "key" is hashed to determine what process to send
data to, which is a means of exploiting parallelism in a streaming
context, akin to a MapReduce operation.
</P>
<P>The sending and receiving of datums between processes is handled
within the PHISH library either by calls to the message-passing
interface (MPI) library, or by sockets via the ZMQ library.  A PHISH
tool converts the input script into a configuration file that can be
launched by either MPI or a shell script.  In the former case, a PHISH
program can run on any platform that supports MPI.  In the latter
case, a PHISH program can run on a single desktop machine or across
any network of (geographically distributed) machines that support
socket connections.
</P>
<HR>

<P>Simple example:link(intro_1),h4
</P>
<HR>

<A NAME = "intro_1"></A><H4>Steps to creating and running a PHISH program 
</H4>
<P>a) write one or more minnows that call the PHISH library
b) write a script listing the minnows and the communication patterns between them
c) ues the Bait.py tool to process the input script
c) run the file (via MPI or a shell script) produced by Bait.py
</P>
<P>PHISH has 2 parts: Python script (bait.py) and library (libphish.a)
</P>
<P>But can also process corpus of files.
</P>
<P>Break stream up into datums = chunk of bytes.
</P>
<HR>

<A NAME = "intro_1"></A><H4>Acknowledgments and citations 
</H4>
<P>PHISH development has been funded by the US Department of Energy (DOE),
through its LDRD program at Sandia National Laboratories.
</P>
<P>The following paper describe the basic ideas in PHISH.  If you use
PHISH in your published work, please cite this paper and include a
pointer to the PHISH WWW Site (http://phish.sandia.gov):
</P>
<P>S. J. Plimpton and T. Shead, PHISH in action, J Parallel and
Distributed Compuing, submitted (2012).
</P>
<P>PHISH was developed by the following folks at Sandia National Labs:
</P>
<UL><LI>Steve Plimpton, sjplimp at sandia.gov
<LI>Tim Shead, tshead at sandia.gov 
</UL>
<P>PHISH comes with no warranty of any kind. As each source file states
in its header, it is a copyrighted code that is distributed free-of-
charge, under the terms of the Berkeley Softward Distribution (BSD)
License. 
</P>
<P>Source code for PHISH is freely available for download from the <A HREF = "phish">PHISH
web site</A> and is licensed under the modified <A HREF = "bsd">Berkeley Software
Distribution (BSD) License</A>.  This basically means they can be
used by anyone for any purpose.  See the LICENSE file provided with
the distribution for more details.
</P>
<P> This is often referred to as open-source distribution - see
www.gnu.org or www.opensource.org for more details.  The BSD license
is the most unrestricted form of an open-source license.  It basically
means that anyone can use the code for any purpose.  The legal text of
the BSD license is in the LICENSE file that is included in the LAMMPS
distribution.
</P>
<HR>

</HTML>
